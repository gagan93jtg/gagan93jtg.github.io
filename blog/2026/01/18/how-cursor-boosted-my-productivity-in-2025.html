<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>How Cursor boosted my productivity in 2025</title>
  <meta name="description" content="I've been working with Cursor for almost a year now. I'm a Senior Engineer at Branch International, where I've been for about 1.5 years. My job mostly involves updating old code or rewriting parts ..." />

  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
  <meta property="og:site_name" content="Gagandeep's Blog" />
  <meta property="og:title" content="How Cursor boosted my productivity in 2025"/>
  
  <meta property="og:description" content="I've been working with Cursor for almost a year now. I'm a Senior Engineer at Branch International, where I've been for about 1.5 years. My job mostly involves updating old code or rewriting parts ..." />
  
  <meta property="og:image" content="https://gagan93.me/blog/assets/images/2026-01-18-cursor-productivity.jpg" />
  <meta property="og:url" content="https://gagan93.me/blog/2026/01/18/how-cursor-boosted-my-productivity-in-2025.html" >
  <meta property="og:type" content="blog" />
  <meta property="article:published_time" content="2026-01-18T00:00:00+05:30">

  <link rel="canonical" href="https://gagan93.me/blog/2026/01/18/how-cursor-boosted-my-productivity-in-2025.html"/>
  <link rel="shortcut icon" href="/blog/assets/images/favicon.png" type="image/png"/>
  <link rel="stylesheet" href="//brick.a.ssl.fastly.net/Linux+Libertine:400,400i,700,700i/Open+Sans:400,400i,700,700i">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" type="text/css" media="screen" href="/blog/css/main.css" />
  <link rel="stylesheet" type="text/css" media="print" href="/blog/css/print.css" />

  <!-- Google tag (gtag.js) -->
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZKG2EDMK4C"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-ZKG2EDMK4C');
    </script>
  
</head>

  <body itemscope itemtype="http://schema.org/Article">
    <!-- header start -->


  <a href="https://gagan93.me/blog" class="logo-readium"><span class="logo" style="background-image: url(https://avatars.githubusercontent.com/u/13852061)"></span></a>

<!-- header end -->

    <main class="content" role="main">
      <article class="post">
        
        <div class="article-image">
          <div class="post-image-image" style="background-image: url(/blog/assets/images/2026-01-18-cursor-productivity.jpg)">
            Article Image
          </div>
          <div class="post-image-image2" style="background-image: url(/blog/assets/images/2026-01-18-cursor-productivity.jpg)">
            Article Image
          </div>
          <div class="post-meta">
            <h1 class="post-title">How Cursor boosted my productivity in 2025</h1>
            <div class="cf post-meta-text">
              <div class="author-image" style="background-image: url(https://avatars.githubusercontent.com/u/13852061)">Blog Logo</div>
              <h4 class="author-name" itemprop="author" itemscope itemtype="http://schema.org/Person">Gagandeep Singh</h4>
              on
              <time datetime="2026-01-18 00:00">18 Jan 2026</time>
            </div>
            <div style="text-align:center">
              <a href="#topofpage" class="topofpage"><i class="fa fa-angle-down"></i></a>
            </div>
          </div>
        </div>
        
        <section class="post-content">
          <div class="post-reading">
            <span class="post-reading-time"></span> read
          </div>
          <a name="topofpage"></a>
          <h2 style="text-align: center;font-size: 0.8em" id="photo-by-aerpscom-on-unsplash">Photo by <a href="https://unsplash.com/@almoya?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Aerps.com</a> on <a href="https://unsplash.com/photos/laptop-displays-the-ai-code-editor-website-wjFOjA2zXy8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></h2>

<h1 id="introduction">Introduction</h1>

<p>I‚Äôve been working with Cursor for almost a year now. I‚Äôm a Senior Engineer at Branch International, where I‚Äôve been for about 1.5 years. My job mostly involves updating old code or rewriting parts of the system, along with some projects for adding new features. Writing new code is often easier, but updating old code is harder ‚Äî you have to make it better and easier to maintain without breaking anything that‚Äôs already working. Before using Cursor, I used Sublime Text for more than 10 years and always preferred fast, simple editors over full-featured IDEs like IntelliJ. I mainly write backend code in Ruby with a bit of frontend work.</p>

<h2 id="2025-was-significant">2025 was significant</h2>

<p>ChatGPT was launched in 2022, making AI accessible to the general public for the first time. Shortly thereafter, tools like GitHub Copilot emerged, leading to a rapid increase in adoption among developers. I personally utilized ChatGPT as a mock interviewer during my interview preparation in early 2024. Cursor was released in late 2024, and I began using it in December of that year. Transitioning to a new editor after more than a decade was challenging, but a few plugins allowed me to recreate my Sublime setup, including shortcuts, extensions, and themes. I have not looked back since. The year 2025 was also pivotal for Cursor as a company. A startup founded by first-time MIT entrepreneurs successfully captured over 50% of the market share, despite facing competition from Microsoft-backed GitHub Copilot and other similar tools.</p>

<p>On a personal note, my daughter was born in March 2025. This change initially threw off my work routine, but with some disciplined deep-work sessions and AI assistance, I managed to get back on track and even boost my productivity.</p>

<h1 id="improved-productivity-with-ai">Improved Productivity with AI</h1>

<p>My role at Branch is filled with exciting opportunities to connect through meetings‚Äîstand-ups, 1:1s, unblocking sessions, interviews, and sometimes process-related discussions. To make the most of my time and keep meetings from taking over, I follow a few strategies:</p>

<ol>
  <li>
    <p>I start my day early, around 8-9 am (depending on how well the baby lets us sleep üòÇ). This allows me to carve out focus slots before meetings begin.</p>
  </li>
  <li>
    <p>I push back or skip meetings where my presence isn‚Äôt crucial. Saving 30‚Äì60 minutes of uninterrupted time is more valuable than being passively present.</p>
  </li>
  <li>
    <p>Weekly 1:1s without progress can become repetitive. Addressing this early frees up time for both parties to focus on what truly matters.</p>
  </li>
  <li>
    <p>I try to schedule one interview per day. Design interviews already last more than an hour so it‚Äôs hard to take multiple interviews in a day.</p>
  </li>
  <li>
    <p>I prioritize attending mandatory org-wide meetings and enjoy the flexibility of watching recordings for the rest.</p>
  </li>
</ol>

<p>After all this, the time left for engineering tasks is limited, so I need to ensure I don‚Äôt waste any of it. I was fortunate to read <a href="https://www.amazon.in/dp/0349413681?ref=ppx_yo2ov_dt_b_fed_asin_title">Deep Work</a> by Cal Newport a few years ago, which helped me apply some ideas to optimize my working style. I also wrote a <a href="https://blog.gagan93.me/habits-productivity-deep-work">detailed post</a> on this topic if you‚Äôre interested in reading more). Since my role involves a lot of refactoring and rewriting, AI tools help me stay productive despite all these meetings.</p>

<h2 id="ai--branch">AI @ Branch</h2>

<p>Before moving ahead, I‚Äôd like to explain how Branch views AI, as its usage becomes increasingly important when the organization encourages widespread adoption. In December 2024, I began using Cursor with a personal subscription. Some developers were already using GitHub Copilot or similar autocomplete tools, but none reported a significant productivity boost. Initially, I used Cursor for autocomplete, but after a few weeks, I started utilizing its agent mode, which allows interaction with AI to accomplish tasks. Having coded independently for over a decade, it took time to trust AI and grant it more control. As more developers in our organization began using Cursor, they reported increased productivity. This topic was discussed in our weekly engineering calls, leading to the creation of a working group to evaluate available tools for potential adoption by the entire team. Options like Copilot, Claude Code, and Cursor were considered, and the team began evaluating them.</p>

<p>The AI landscape is constantly evolving, making it challenging to conclude research. However, by mid-year, Branch had enterprise accounts for multiple AI tools, allowing developers to choose based on their preferences, IDE, and comfort level. Additionally, we hosted a hackathon where participants from outside the engineering team built projects without prior coding knowledge. This was just the beginning, and the organization is still working on optimizing workflows for all teams using the available tools.</p>

<h1 id="my-cursor-usage">My Cursor Usage</h1>

<p>I started using Cursor like you all did - <em>tab tab tab</em> ü§£. These tools quickly grasp the context of your code. If you‚Äôre still writing all the code yourself, you‚Äôll notice it peeking into your work and completing a line of code for you, suggesting the next line, or even the entire method. This is the most basic use of any AI-based editor.</p>

<p>Below, I‚Äôll talk about my setup, some tweaks, and my usage style that boosted my productivity in 2025.</p>

<h2 id="understanding-different-models---cost-vs-quality">Understanding Different models - Cost vs. quality</h2>

<p><img src="/blog/assets/images/2026-01-18-models.png" alt="Personal screenshot" style="display: block; margin: 10px auto;" /></p>

<p>Just like other tools, Cursor supports multiple LLM models from different vendors ranging from OpenAI‚Äôs GPT models to Anthropic‚Äôs <em>Opus/Sonnet,</em> Google‚Äôs Gemini and their own recently launched model <em>Composer 1.</em> I won‚Äôt go into comparisons of these models but you must have a basic understanding of when to use different models. When choosing between different AI models, it‚Äôs important to consider their strengths and limitations. Thinking models such as Opus and Sonnet are better suited for complex tasks due to their advanced reasoning capabilities and ability to handle nuanced queries. However, these models can be slower and may require more computational resources. On the other hand, models like Composer are designed for speed and efficiency, making them ideal for tasks that require quick responses but are not overly complex. Additionally, context windows play a crucial role in determining how much information a model can process at once. Larger context windows allow models to consider more information simultaneously, which is beneficial for understanding intricate problems. However, ‚Äúlarger context‚Äù also means slower processing times for a long running thread.</p>

<p>I‚Äôve been using Cursor in <strong>auto</strong> mode for many months. It picks a model based on the task, but sometimes the responses were too slow, so I started trying different models. Here are a few reasons for the slowness:</p>

<ol>
  <li>
    <p>When the context window was about 80-90% full, it became large enough to slow down future conversations.</p>
  </li>
  <li>
    <p>At around 98-99%, many conversations just stopped, and I had to start a new one, losing all the context üòî.</p>
  </li>
  <li>
    <p>Sometimes, there was random slowness, which suggested their API might have been down or slow, like any other backend service.</p>
  </li>
</ol>

<p>Thankfully, by September 2025 Cursor launched <strong>context summarisation</strong> that triggers automatically. You can also use <code class="language-plaintext highlighter-rouge">/summarize</code> command to trigger it on-demand.</p>

<p>Just like everyone else, I love coding quickly, so I tried out Cursor‚Äôs Composer model. I usually give smaller tasks with clear context to Cursor, and Composer-1 handled these simple tasks pretty well. I chatted with my colleagues about it, and they found it to be an average model for anything more complex. These days, I use a mix of Sonnet, Opus, and Composer for my projects.</p>

<h2 id="configuring-how-agents-work">Configuring how agents work</h2>

<p>There are various ways in which you can provide a good <strong>initial context</strong> to the agent before it starts working on your task according to your prompt. As we‚Äôre using both Copilot and Cursor in our organisation, few folks from a working group have spent some time defining the configuration for both of these tools. Copilot searches for <code class="language-plaintext highlighter-rouge">.github/copilot-instructions.md</code> in your repository rules whereas Cursor has multiple ways of defining <a href="https://cursor.com/docs/context/rules">rules</a> and configuring the agent (eg. using <code class="language-plaintext highlighter-rouge">AGENTS.md</code>). When you are defining these configurations, consider including things like:</p>

<ol>
  <li>
    <p><strong>Project‚Äôs coding standards</strong>: Provide detailed guidelines for designing and organizing components within the codebase. This includes specifying folder structures, naming conventions, and rules for using components like models, services, and controllers. It ensures consistency and adherence to best practices across the project.</p>
  </li>
  <li>
    <p><strong>Workflow Selection Criteria</strong>: Clearly define the conditions under which each workflow should be selected. This includes specifying when product, design, coding, testing, and review workflows are applicable. This ensures that the appropriate workflow is triggered based on the task requirements.</p>
  </li>
  <li>
    <p><strong>Testing and Domain Specifications</strong>: Outline the testing plan, including the types of tests and their locations. This helps in maintaining a clear understanding of the project‚Äôs structure and ensures comprehensive testing coverage.</p>
  </li>
  <li>
    <p><strong>Error Handling and Logging</strong>: Define how errors should be handled within each workflow. Include guidelines for logging errors and exceptions to ensure that issues can be tracked and resolved efficiently.</p>
  </li>
  <li>
    <p><strong>Security and Compliance</strong>: Outline any security protocols or compliance requirements that need to be adhered to during the development process. This could include data protection measures, access controls, and encryption standards.</p>
  </li>
</ol>

<p>In brief, treat the agent as an integral part of your engineering team by providing it with a comprehensive understanding of the problem you‚Äôre addressing. This approach ensures that each task the agent undertakes aligns with the expected quality standards. However, be mindful not to overload the initial context with excessive details, as this could consume a significant portion of the context window or lead to some instructions being overlooked. For example, if there are some very specific instructions, don‚Äôt include them in this configuration. You can mention those instructions or provide some files as a reference while solving that particular task.</p>

<h2 id="planning-is-still-the-most-important-step">Planning is still the most important step</h2>

<p>A detailed task description is crucial for successful AI integration, as the quality of the output is directly related to the clarity of the input‚Äîessentially, <strong>garbage in, garbage out</strong>. By providing clear and comprehensive instructions, you enable AI to deliver more accurate and useful results.</p>

<p>I‚Äôve written some internal posts at my organization on how to effectively break down and estimate tasks. Throughout my career, I have observed that many engineers face challenges with medium to large projects due to lack of proficiency in breaking them down into milestones and tasks. Projects often begin smoothly, but confusion tends to arise midway, leading to a rushed conclusion. This typically results in the submission of large pull requests with a significant <strong>blast radius</strong>.</p>

<p>With AI as your assistant, planning still remains one of the most important task in SDLC. Those who have reaped the most benefits from AI are typically individuals who excel at <strong>planning</strong> and <strong>breaking</strong> tasks. They understand that AI is not a magic wand that can replace the need for skilled software engineers. but a powerful tool that can enhance productivity when used correctly.</p>

<p>I‚Äôm not great at writing long prompts, so I‚Äôve been handling my projects by breaking them down myself. I often have design discussions with AI when needed and then assign individual tasks to the tools to solve. This approach has worked well and quickly for me because:</p>

<ol>
  <li>
    <p>Not everything is outsourced to AI so I completely understand the problem statement. At times, it‚Äôs easy to lose context of the problem at hand by completely letting AI solve it.</p>
  </li>
  <li>
    <p>Smaller problems are solved faster, so I can see the results immediately. I can then proceed to testing and raising smaller PRs for the individual tasks.</p>
  </li>
  <li>
    <p>The code might be generated using AI but it will be committed against my name. In the future, if something breaks then the ownership is on me, not on AI. So it‚Äôs very important to completely go through the generated code. Even if the code is completely covered by test cases, I don‚Äôt get a feeling of satisfaction unless the I completely understand the generated and it looks maintainable enough. By working with smaller diffs, it‚Äôs easier to review the generated code completely before commiting</p>
  </li>
</ol>

<p>Just like speed, I‚Äôm also a fan of <strong>smaller feedback loops</strong> so I wrote a <a href="https://gagan93.me/blog/2023/05/01/small-testing-loops.html">very short blog</a> on it years ago.</p>

<h2 id="deeper-integrations">Deeper integrations</h2>

<p>Cursor also has integration with our issue tracker (Linear) and version control system (Github). By simply tagging <code class="language-plaintext highlighter-rouge">@cursor</code> on a ticket, we can launch a background agent that reads the requirement, understands it, and directly raises a pull request on Github with explanation of the changes. A developer can simply check the diff, see if it meets the requirements &amp; coding standards, and merge the PR üöÄ.</p>

<p>Our role as engineers is evolving from primarily writing code to focusing on creating comprehensive and detailed tasks from Product Requirement Documents (PRDs) and design documents. This shift allows AI to handle these tasks efficiently and accurately.</p>

<h2 id="understanding-legacy-code">Understanding legacy code</h2>

<p>Most of us join teams with existing codebases, often over a decade old, which can be difficult to understand at times. While those who witnessed the evolution of the system can grasp the reasons behind changes, newcomers may struggle to comprehend the current state. Code that spans multiple files or has high cyclomatic complexity is challenging to interpret.</p>

<p>AI tools are quite useful in these situations. I‚Äôve been using AI extensively to understand and rewrite legacy systems. Both Cursor and Copilot have a read-only ‚ÄúAsk‚Äù mode which is particularly useful for learning and exploration, unlike the default ‚ÄúAgent‚Äù mode that is more suited for updating the code.</p>

<p>It‚Äôs hard for humans to unlearn ‚Äî once a certain way of thinking or solving problems is ingrained, stepping back and approaching it with a completely fresh perspective takes conscious effort but AI can provide a fresh perspective on problems and suggest solutions as soon as you start a new chat window.</p>

<p>While detailed prompts are recommended to execute tasks as per your expectation, it has been beneficial for me to ask AI random questions like ‚Äú<em>Why is this test case slow</em>‚Äù. AI would then inspect the file, our test setup, and all the related files to give a fresh perspective into our setup. Without AI, you would generally treat most of the setup as source of truth. Other examples of random questions include ‚Äú<em>How can this function be optimized</em>?‚Äù or ‚Äú<em>What are potential security vulnerabilities in this code</em>?‚Äù These inquiries can reveal valuable insights and improvements. Additionally, AI can assist in design discussions, offering innovative ideas and solutions that might not be immediately apparent to human developers.</p>

<h2 id="running-shell-commands">Running shell commands</h2>

<p>Often, the agent might need to run a script or execute a shell command. While it might seem risky to let AI access beyond the editor, there are safe ways to do it. Currently, both Cursor and Copilot can run shell commands from the editor‚Äôs AI agent and use the output to proceed.</p>

<p>These tools use an <strong>allow list</strong> to make this process quicker and safer. When an agent needs to run a shell command, it offers three choices: <strong>Skip</strong>, <strong>Run</strong>, and <strong>Add to allow list</strong>. Adding a command to the allow list means that next time, it can run without your permission. This feature is very helpful because I often found Cursor running read-only commands like <code class="language-plaintext highlighter-rouge">wc</code>, <code class="language-plaintext highlighter-rouge">awk</code>, <code class="language-plaintext highlighter-rouge">grep</code>, and <code class="language-plaintext highlighter-rouge">sort</code> safely, so it made sense to whitelist these commands. Without this feature, you would have to constantly approve commands in your editor.</p>

<p>It‚Äôs not safe to whitelist commands like <code class="language-plaintext highlighter-rouge">rm</code>, but since I frequently commit my code, I‚Äôve whitelisted them too. Because Cursor doesn‚Äôt run with sudo privileges, this setup is both safe and efficient. For the past two months, I‚Äôve been working on projects that required rewriting the controller layer for many modules. One of my testing goals was to ensure that the JSON output from the old and new controllers matched. If there were differences, I needed to know exactly what changed. I used AI-written scripts to compare each nested key in the JSONs to avoid regression issues. Directly asking AI agents to compare the JSONs could work but might be less precise, so I had it write a script for this task.</p>

<h2 id="for-writing-tests">For writing tests</h2>

<p>Tests are essential for identifying regressions and instilling confidence in the codebase over time. They ensure that new changes do not disrupt existing functionality and help maintain the software‚Äôs integrity. Many developers now use AI to write tests, including those who previously avoided writing them. I have long advocated for writing tests, even before the widespread adoption of AI agents. There are two main approaches to writing tests: one targets achieving 100% code coverage, while the other focuses on covering meaningful scenarios. I will outline my approach to writing tests:</p>

<ol>
  <li>
    <p>I‚Äôm not into Test-Driven Development (TDD), but I ensure that I write tests for most of the features I touch.</p>
  </li>
  <li>
    <p>As the code is already written and I maintain a clean coding style, I can easily identify which code paths need testing.</p>
  </li>
  <li>
    <p>I determine the types of tests required, which generally include unit tests (for individual classes), controller tests (to test a controller‚Äôs journey), and end-to-end tests (covering complete scenarios involving multiple controller invocations).</p>
  </li>
  <li>
    <p>To avoid reviewing subpar AI-generated code, I provide an initial structure for the AI to follow, allowing it to handle the repetitive tasks.</p>
  </li>
</ol>

<p>A sample in Ruby might look like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">RSpec</span><span class="p">.</span><span class="nf">describe</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span> <span class="k">do</span>
  <span class="c1"># leave setup data for AI</span>

  <span class="n">describe</span> <span class="s1">'#method_to_test1'</span> <span class="k">do</span>
    <span class="n">context</span> <span class="s1">'when scenario 1'</span> <span class="k">do</span>
      <span class="c1"># leave this for AI to fill</span>
    <span class="k">end</span>

    <span class="n">context</span> <span class="s1">'when scenario 2'</span> <span class="k">do</span>
      <span class="c1"># leave this for AI to fill</span>
    <span class="k">end</span>
   <span class="o">...</span>
  <span class="k">end</span>

  <span class="n">describe</span> <span class="s1">'#method_to_test2'</span> <span class="k">do</span>
    <span class="n">context</span> <span class="s1">'when scenario 1'</span> <span class="k">do</span>
      <span class="c1"># leave this for AI to fill</span>
    <span class="k">end</span>

    <span class="n">context</span> <span class="s1">'when scenario 2'</span> <span class="k">do</span>
      <span class="c1"># leave this for AI to fill</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I‚Äôve been encouraging my juniors to write tests this way (since before the AI era) ‚Äî first list the scenarios, then dive into the details. Doing it this way ensures you think through the scenarios carefully without getting into the specifics of setup code or mocks. If you start writing tests for one scenario without defining all of them, you might have to switch your focus between thinking about cases and writing the actual test cases. Fortunately, the grunt work can now be outsourced üòé.</p>

<p>I‚Äôve also tried without giving AI the structure and I didn‚Äôt get good output. But it was some time ago, maybe the models have improved now. Or a better idea would be to frame the prompt like this:</p>

<blockquote>
  <p>Write tests cases for @this_file. Refer @that_file for understanding how to organise the scenarios.</p>
</blockquote>

<h2 id="mcp-servers">MCP servers</h2>

<p>If you have not yet explored MCP servers, you‚Äôre missing out on some serious automation. Most of the popular websites have rolled out their MCP servers and people are already building agents over them üöÄ. While I‚Äôve not developed any full fledged agentic workflows yet, these are the things that I‚Äôve used MCP for:</p>

<ol>
  <li>
    <p><strong>Debugging high impact production issue</strong> - Our major backend web application is a monolith that‚Äôs deployed twice a week. Every month, I get to handle my team‚Äôs on call for a week. In August 2025, I got an issue assigned that was causing problem in a specific module which was essential for all markets, so it had a major impact. Seeing the charts, it was clear that something started breaking after the most recent deployment. While rolling back the entire release was an option, it is not always the preferred path because a release contains work of multiple developers and unless it‚Äôs a SEV0, you would not want to revert everyone‚Äôs work. But I was not able to catch the issue by manually looking into the code as there were no recent changes around the impacted code or it‚Äôs parent classes. I had recently integrated Github MCP with Cursor, and I thought of debugging this issue with MCP integration. Because each release going to production has a PR, I gave the PR link and the exception trace to Cursor and asked it to debug the same using Github MCP tools. Within a minute, it was able to point out that a framework upgrade has also went live within the same release and some methods we used in our module could have been impacted in the newer version. It gave me a direction to look into and that was the exact issue which I fixed later and released within next one hour.</p>
  </li>
  <li>
    <p><strong>Filing &gt;100 tickets</strong> - We use Linear as our issue tracker and I had a use case of filing many linear tickets with a given title and details. Apart from this, the tickets had to be assigned to people from multiple teams so I had to ensure that the project is linked to their team‚Äôs board. I spent half hour with Cursor and I was able to file 100+ tickets with accurate details and team information. In a pre-AI world, this would anyways be done with a script but the effort of writing that by hand got eliminated.</p>
  </li>
  <li>
    <p><strong>Frontend tasks</strong> - I recently got assigned some UI work for an urgent task. While I‚Äôve been a full-stack engineer but my inclination has been towards backend only. I googled and found out that our design platform (Figma) also has a MCP server that can be connected to AI editors. Within minutes, I could access designs from my editor and give commands to build specific parts of the page. This entirely eliminated the mental effort in building UI structure by hand.</p>
  </li>
</ol>

<h2 id="avoiding-ai-slop">Avoiding AI Slop</h2>

<blockquote>
  <p>AI slop code refers to low-quality, often buggy, insecure, or nonsensical code generated rapidly by AI tools, lacking true value or originality, and is a significant concern as it can introduce errors like missed security checks, hallucinated functions, and inefficiency, but can be avoided by experienced developers using AI as a supplement, not a replacement, and always validating the output.</p>
</blockquote>

<p>It‚Äôs very common to get excited with everything happening in the AI world and put it in the driver‚Äôs seat, but that can quickly backfire. AI models work by predicting the next token based on patterns learned from large datasets. They don‚Äôt truly understand your system, its constraints, or its long-term trade-offs. Because of this, the output may look correct and even pass tests, yet still be suboptimal, brittle, or misaligned with your architecture. Your organisation has hired you, not an AI agent, so it‚Äôs your responsibility to ensure that while AI output helps you move faster, it doesn‚Äôt quietly introduce slop into the codebase.</p>

<p>Few months ago, when more people in our team started using AI tools, I got to see a lot of obvious comments after every few lines in their pull requests. If you‚Äôve been a Ruby developer, you know that the <a href="https://github.com/rubocop/ruby-style-guide?tab=readme-ov-file#comments">style guide</a> says this about comments:</p>

<blockquote>
  <p>Good code is its own best documentation. As you‚Äôre about to add a comment, ask yourself, ‚ÄúHow can I improve the code so that this comment isn‚Äôt needed?‚Äù. Improve the code and then document it to make it even clearer.</p>
</blockquote>

<p>Having coding in Ruby for more than a decade, I generally write close to zero comments in my code (feel free to call me extremist here üòÇ). There are very rare cases sometimes when you see a specific complexity in the codebase that would take time to refactor so in those cases I leave a useful comment. This is one example of AI slop but there can be many more. For example, if you‚Äôre designing web pages using AI and you don‚Äôt give them sufficient context of your overall application and design scheme, the AI agent would end up redefining a lot of unneeded CSS inline just to match the design.</p>

<p>In my knowledge, there are two easy ways to avoid such slop:</p>

<ol>
  <li>
    <p>Define the <code class="language-plaintext highlighter-rouge">Agent.md</code>, <code class="language-plaintext highlighter-rouge">copilot-instructions.md</code> or similar files to setup top level behaviour for the agent.</p>
  </li>
  <li>
    <p>Ensure your prompts are clear enough so that no slop is generated.</p>
  </li>
</ol>

<p>Even then if you get any such sloppy code, it‚Äôs your responsibility to clean that up manually before committing.</p>

<h1 id="is-ai-eliminating-software-engineers">Is AI eliminating software engineers?</h1>

<p>From my personal experience, and from listening to respected industry voices, I‚Äôve concluded that AI today can help you build apps from scratch and even get some paying users. But building serious applications is still fundamentally a system design problem that needs experienced engineers. You need a simpler stack, fewer proxies, fewer network hops, and carefully optimised code to run systems efficiently at scale.</p>

<p>Also, in the realm of serious software development, writing code is just one part of the job. A significant amount of effort goes into prioritizing tasks, deciding on product behavior, managing releases, providing post-release support, ensuring observability, debugging through logs and metrics, and handling incidents. Automating parts of code writing, even though they still need testing, reviewing, merging, and releasing, optimizes about 15-20% of the overall process.</p>

<p>Still AI saves a lot of valuable time for the engineers and significantly reduces costs, which is truly impressive. So if you ask me: <em>Do we still need developers</em>?. I‚Äôd say <strong>absolutely</strong>. We probably need fewer of them.</p>

<h2 id="two-edged-sword">Two edged sword</h2>

<p>AI is undeniably powerful and already indispensable. The challenge is to use it as a leverage tool, not as a crutch, so that we don‚Äôt trade long-term engineering strength for short-term speed. While I regularly use AI in my work, I see a few long-term issues that are worth talking about:</p>

<ol>
  <li>
    <p><strong>Today vs 5-10 Years Ago</strong> - I started coding professionally in 2015, when StackOverflow was the OG. Until around 2022, someone who coded fast was usually someone who had coded for years and had built both speed and expertise by writing code for a long time. That relationship has changed. AI now makes everyone a designer, a poet, and a coder. The problem is not capability, it‚Äôs learning. A large part of the learning is shifting from humans to machines. For example, I‚Äôm fluent in Ruby and reasonably comfortable with Java and JavaScript. If you ask me to write C or C++, I‚Äôll still open an editor like Vim and rely on what I learned in college 12‚Äì13 years ago. But if you ask me to write Go or Rust today, I‚Äôll most likely describe the idea to an AI editor. I‚Äôll ship a ‚Äúhello world‚Äù in seconds and probably an MVC app in days, but I may never become truly comfortable with those languages without AI. Human brains get comfortable with syntax by writing it again and again. Outsourcing that repetition to AI speeds up delivery, but it slows down internalisation. While writing this, I also remembered my first company‚Äôs interview process, where I wrote C++ code with pen and paper ü§†. Will people ever do that again? Maybe I‚Äôm overthinking or sounding old, but the idea is simple: programming languages are slowly becoming interfaces for people who don‚Äôt deeply understand their syntax, treating engineers and non-engineers alike. The upside is that new developers will ship and debug production code much faster than we ever did. The downside is that it may take them much longer to become fluent in any one language. Whether this is good or bad ‚Äî only time will tell.</p>
  </li>
  <li>
    <p><strong>Long-Term Maintainability</strong> - A big worry is ‚ÄúAI slop.‚Äù Code gets approved not because it‚Äôs well understood, but because it works and passes tests. Developers might accept suggestions they don‚Äôt fully understand, especially when rushed. Over time, this results in codebases that are harder to understand, harder to change, and fragile in unexpected ways.</p>
  </li>
  <li>
    <p><strong>Skill Atrophy and Debugging Depth</strong> - When AI writes most of the scaffolding and glue code, developers spend less time building a mental model of the system. This can show up during incidents. Debugging distributed systems, performance issues, or subtle data bugs still requires deep understanding, not just good prompts. If that understanding erodes, incident recovery times can increase, even if development felt faster initially.</p>
  </li>
  <li>
    <p><strong>Lock-In and Rising Costs</strong> - Currently, AI tools are relatively affordable due to growing adoption and high competition. However, as teams and individuals become increasingly dependent on these tools, pricing power will shift. When these tools become essential for development, costs are likely to rise. At that point, opting out will be mentally challenging. While the costs might still be more justifiable than hiring additional engineers, only time will reveal how cost-effective these tools will remain.</p>
  </li>
</ol>

<h1 id="personal-targets-for-2026">Personal targets for 2026</h1>

<p>With 2025 bringing so many improvements in these AI models, I‚Äôm excited to see what we have for 2026 and beyond. For this year, I‚Äôm looking to try out a few things:</p>

<ol>
  <li>
    <p><strong>Agentic workflows</strong> -Automation has been around in software engineering for a long time, but creating it has become easier with Agentic workflows. I explored tools like n8n in late 2025 when my manager made a small agent to set up a daily alert on some reports. Building agentic workflows on these platforms is like drawing diagrams. It‚Äôs easier because of the visuals, and it lowers costs by cutting out</p>

    <p>the need for software engineers. While the tool is very powerful, I didn‚Äôt have any ideas to implement, so I didn‚Äôt create any agentic workflows last year. I‚Äôm usually not great with ideas, but I‚Äôm hopeful that this year I‚Äôll develop an agentic workflow for personal use or a production application. Let‚Äôs see if I can achieve this üòé.</p>
  </li>
  <li>
    <p><strong>Cursor commands</strong> (<a href="https://cursor.com/docs/agent/chat/commands">more</a>) - I‚Äôve heavily used cursor this year and often searched for old chats when I had to perform similar tasks so that I‚Äôm not required to provide the same prompt again. While this is doable and context window isn‚Äôt a problem after <a href="https://cursor.com/docs/agent/chat/summarization#how-summarization-works">context summarisation</a> feature, a better method would be to create reusable prompts and commit them to the respective repo. I‚Äôll try to find such use cases and create their cursor commands to help both myself and the wider team.</p>
  </li>
  <li>
    <p><strong>Agent skills</strong> (<a href="https://code.claude.com/docs/en/skills">more</a>) - I got to hear about this very recently. The idea is that agent can pick a skill to perform a specific task and using a markdown file, it would know how to do that task in your preferred way. I believe this would mean that you no longer need long, carefully crafted prompts or repeated context-setting every time you need to perform these tasks since the agent already knows how to perform the task, what steps to follow, and what constraints to respect.</p>
  </li>
  <li>
    <p><strong>End to end execution with AI</strong> - For small projects, I generally start implementing my tasks without creating detailed technical tasks from the PRD. Even for technical projects, I‚Äôve seen that my project description is detailed but the individual tasks have minimal information. Recently, some folks in my organisation are exploring AI for end to end execution. The flow looks like:</p>

    <ol>
      <li>
        <p>Create a design doc from PRD (manually or with AI‚Äôs help).</p>
      </li>
      <li>
        <p>Use AI to create project, tasks and milestones from design doc. These tasks would include required details with code snippets, or any other thing that would help the agent understand the context deeply.</p>
      </li>
      <li>
        <p>Run agents (sequentially or parallelly) to execute each task and monitor the generated code.</p>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>Parallel agents / subagents</strong> - Till now, my way of using AI has been to give it a task and stay glued to the editor screen because the tasks are small enough and agent respond mostly within a minute. But the real power lies in giving them different tasks simultaneously to improve efficiency.</p>
  </li>
</ol>

<h1 id="conclusion">Conclusion</h1>

<p>As the AI landscape has evolved in 2025, it feels increasingly realistic to pursue these goals and even beyond. The steady pace of improvement in AI tools opens up new possibilities for efficiency and experimentation, but it also comes with trade-offs that require thoughtful adoption rather than blind optimism. With a focus on learning, adapting, and using these tools deliberately within real-world constraints, I see room to make meaningful progress without losing sight of engineering fundamentals.</p>

<p>I‚Äôd genuinely like to learn from others here. So if you‚Äôve developed useful workflows, or discovered patterns that work well in real production environments, please share them in comments.</p>

        </section>
        <footer class="post-footer">
          <section class="share">
            
              
            
              
            
          </section>
        </footer>
        <div class="bottom-teaser cf">
          <div class="isLeft">
            <h5 class="index-headline featured"><span>Written by</span></h5>
            <section class="author">
              <div class="author-image" style="background-image: url(https://avatars.githubusercontent.com/u/13852061)">Blog Logo</div>
              <h4>Gagandeep Singh</h4>
              <p class="bio"></p>
              <hr>
              <p class="published">Published <time datetime="2026-01-18 00:00">18 Jan 2026</time></p>
            </section>
          </div>
          <div class="isRight">
            <h5 class="index-headline featured"><span>Supported by</span></h5>
            <footer class="site-footer">
              <section class="poweredby">Made with ‚ù§Ô∏è using <a href="http://jekyllrb.com"> Jekyll</a></section>
              <a class="subscribe" href="/blog/feed.xml"> <span class="tooltip"> <i class="fa fa-rss"></i> RSS feed</span></a>
              <div class="inner">
                <section class="copyright">All content copyright &copy; 2026<br>All rights reserved.</section>
              </div>
            </footer>
          </div>
        </div>
        
      </article>
    </main>
    <div class="bottom-closer">
      <div class="background-closer-image"  style="background-image: url(/blog/assets/images/cover.jpg)">
        Image
      </div>
      <div class="inner">
        <a href=/blog/ class="btn">Back to All Posts</a>
      </div>
    </div>
    <script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="/blog/assets/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/blog/assets/js/index.js"></script>
<script type="text/javascript" src="/blog/assets/js/readingTime.min.js"></script>
<script>
(function ($) {
  "use strict";
  $(document).ready(function(){

    var $window = $(window),
    $image = $('.post-image-image, .teaserimage-image, .post-image-image2');
    
      $window.on('scroll', function() {
        var top = $window.scrollTop();

        if (top < 0 || top > 1500) { return; }
        $image
          .css('transform', 'translate3d(0px, '+top/3+'px, 0px)')
          .css('opacity', 0.5-Math.max(top/1400, 0));
      });
      $window.trigger('scroll');

      var height = $('.article-image').height();
      $('.post-content').css('padding-top', height + 'px');

      $('a[href*=#]:not([href=#])').click(function() {
        if (location.pathname.replace(/^\//,'') == this.pathname.replace(/^\//,'')
         && location.hostname == this.hostname) {
          var target = $(this.hash);
          target = target.length ? target : $('[name=' + this.hash.slice(1) +']');
          if (target.length) {
            $('html,body').animate({ scrollTop: target.offset().top }, 500);
            return false;
          }
        }
      });

  });
}(jQuery));
</script>

  </body>
</html>
